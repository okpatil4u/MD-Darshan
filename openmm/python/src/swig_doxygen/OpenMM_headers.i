/* Swig input file,
   generated by /Users/peastman/OpenMM4.1-Source/bin/python/src/swig_doxygen/swigInputBuilder.py on Thu Apr 26 10:43:32 2012
*/



namespace OpenMM {


/* Force subclasses */

%factory(OpenMM::Force& OpenMM::System::getForce,
         OpenMM::AmoebaGeneralizedKirkwoodForce,
         OpenMM::AmoebaHarmonicAngleForce,
         OpenMM::AmoebaHarmonicBondForce,
         OpenMM::AmoebaHarmonicInPlaneAngleForce,
         OpenMM::AmoebaMultipoleForce,
         OpenMM::AmoebaOutOfPlaneBendForce,
         OpenMM::AmoebaPiTorsionForce,
         OpenMM::AmoebaStretchBendForce,
         OpenMM::AmoebaTorsionForce,
         OpenMM::AmoebaTorsionTorsionForce,
         OpenMM::AmoebaUreyBradleyForce,
         OpenMM::AmoebaVdwForce,
         OpenMM::AmoebaWcaDispersionForce,
         OpenMM::AndersenThermostat,
         OpenMM::CMAPTorsionForce,
         OpenMM::CMMotionRemover,
         OpenMM::CustomAngleForce,
         OpenMM::CustomBondForce,
         OpenMM::CustomExternalForce,
         OpenMM::CustomGBForce,
         OpenMM::CustomHbondForce,
         OpenMM::CustomNonbondedForce,
         OpenMM::CustomTorsionForce,
         OpenMM::GBSAOBCForce,
         OpenMM::GBSAOBCSoftcoreForce,
         OpenMM::GBVIForce,
         OpenMM::GBVISoftcoreForce,
         OpenMM::HarmonicAngleForce,
         OpenMM::HarmonicBondForce,
         OpenMM::MonteCarloBarostat,
         OpenMM::NonbondedForce,
         OpenMM::NonbondedSoftcoreForce,
         OpenMM::PeriodicTorsionForce,
         OpenMM::RBTorsionForce);


/* Global Constants */

static const double NmPerAngstrom = 0.1;
static const double AngstromsPerNm = 10.0;
static const double PsPerFs = 0.001;
static const double FsPerPs = 1000.0;
static const double KJPerKcal = 4.184;
static const double KcalPerKJ = 1.0/4.184;
static const double RadiansPerDegree = 3.1415926535897932385/180.0;
static const double DegreesPerRadian = 180.0/3.1415926535897932385;
static const double SigmaPerVdwRadius = 1.7817974362806786095;
static const double VdwRadiusPerSigma = .56123102415468649070;


/* Forward Declarations */

class Force ;
%copyctor AmoebaGeneralizedKirkwoodForce ;
class AmoebaGeneralizedKirkwoodForce ;
%copyctor AmoebaHarmonicAngleForce ;
class AmoebaHarmonicAngleForce ;
%copyctor AmoebaHarmonicBondForce ;
class AmoebaHarmonicBondForce ;
%copyctor AmoebaHarmonicInPlaneAngleForce ;
class AmoebaHarmonicInPlaneAngleForce ;
%copyctor AmoebaMultipoleForce ;
class AmoebaMultipoleForce ;
%copyctor AmoebaOutOfPlaneBendForce ;
class AmoebaOutOfPlaneBendForce ;
%copyctor AmoebaPiTorsionForce ;
class AmoebaPiTorsionForce ;
%copyctor AmoebaStretchBendForce ;
class AmoebaStretchBendForce ;
%copyctor AmoebaTorsionForce ;
class AmoebaTorsionForce ;
%copyctor AmoebaTorsionTorsionForce ;
class AmoebaTorsionTorsionForce ;
%copyctor AmoebaUreyBradleyForce ;
class AmoebaUreyBradleyForce ;
%copyctor AmoebaVdwForce ;
class AmoebaVdwForce ;
%copyctor AmoebaWcaDispersionForce ;
class AmoebaWcaDispersionForce ;
%copyctor AndersenThermostat ;
class AndersenThermostat ;
class Integrator ;
%copyctor BrownianIntegrator ;
class BrownianIntegrator ;
%copyctor CMAPTorsionForce ;
class CMAPTorsionForce ;
%copyctor CMMotionRemover ;
class CMMotionRemover ;
%copyctor Context ;
class Context ;
%copyctor CustomAngleForce ;
class CustomAngleForce ;
%copyctor CustomBondForce ;
class CustomBondForce ;
%copyctor CustomExternalForce ;
class CustomExternalForce ;
%copyctor CustomGBForce ;
class CustomGBForce ;
%copyctor CustomHbondForce ;
class CustomHbondForce ;
%copyctor CustomIntegrator ;
class CustomIntegrator ;
%copyctor CustomNonbondedForce ;
class CustomNonbondedForce ;
%copyctor CustomTorsionForce ;
class CustomTorsionForce ;
%copyctor GBSAOBCForce ;
class GBSAOBCForce ;
%copyctor GBSAOBCSoftcoreForce ;
class GBSAOBCSoftcoreForce ;
%copyctor GBVIForce ;
class GBVIForce ;
%copyctor GBVISoftcoreForce ;
class GBVISoftcoreForce ;
%copyctor HarmonicAngleForce ;
class HarmonicAngleForce ;
%copyctor HarmonicBondForce ;
class HarmonicBondForce ;
%copyctor LangevinIntegrator ;
class LangevinIntegrator ;
class LocalEnergyMinimizer ;
%copyctor MonteCarloBarostat ;
class MonteCarloBarostat ;
%copyctor NonbondedForce ;
class NonbondedForce ;
%copyctor NonbondedSoftcoreForce ;
class NonbondedSoftcoreForce ;
%copyctor OpenMMException ;
class OpenMMException ;
class VirtualSite ;
%copyctor OutOfPlaneSite ;
class OutOfPlaneSite ;
%copyctor PeriodicTorsionForce ;
class PeriodicTorsionForce ;
class Platform ;
%copyctor RBTorsionForce ;
class RBTorsionForce ;
%copyctor RPMDIntegrator ;
class RPMDIntegrator ;
class SerializationNode ;
%copyctor SerializationProxy ;
class SerializationProxy ;
%copyctor System ;
class System ;
%copyctor ThreeParticleAverageSite ;
class ThreeParticleAverageSite ;
%copyctor TwoParticleAverageSite ;
class TwoParticleAverageSite ;
%copyctor VariableLangevinIntegrator ;
class VariableLangevinIntegrator ;
%copyctor VariableVerletIntegrator ;
class VariableVerletIntegrator ;
%copyctor VerletIntegrator ;
class VerletIntegrator ;
class XmlSerializer ;


/* Class Declarations */

class Force {
public:
   virtual ~Force() ;

   int getForceGroup() const ;
   void setForceGroup(int group) ;
};

class AmoebaGeneralizedKirkwoodForce : public Force {
public:
   AmoebaGeneralizedKirkwoodForce() ;

   int getNumParticles() const ;
   int addParticle(double charge, double radius, double scalingFactor) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & radius };
   %apply double & OUTPUT { double & scalingFactor };
   void getParticleParameters(int index, double &charge, double &radius, double &scalingFactor) const ;
   %clear double & charge;
   %clear double & radius;
   %clear double & scalingFactor;
   void setParticleParameters(int index, double charge, double radius, double scalingFactor) ;
   double getSolventDielectric() const ;
   void setSolventDielectric(double dielectric) ;
   double getSoluteDielectric() const ;
   void setSoluteDielectric(double dielectric) ;
   int getIncludeCavityTerm() const ;
   void setIncludeCavityTerm(int includeCavityTerm) ;
   double getProbeRadius() const ;
   void setProbeRadius(double probeRadius) ;
   double getSurfaceAreaFactor() const ;
   void setSurfaceAreaFactor(double surfaceAreaFactor) ;
};

class AmoebaHarmonicAngleForce : public Force {
public:
   AmoebaHarmonicAngleForce() ;

   int getNumAngles() const ;
   void setAmoebaGlobalHarmonicAngleCubic(double cubicK) ;
   double getAmoebaGlobalHarmonicAngleCubic(void) const ;
   void setAmoebaGlobalHarmonicAngleQuartic(double quarticK) ;
   double getAmoebaGlobalHarmonicAngleQuartic(void) const ;
   void setAmoebaGlobalHarmonicAnglePentic(double penticK) ;
   double getAmoebaGlobalHarmonicAnglePentic(void) const ;
   void setAmoebaGlobalHarmonicAngleSextic(double sexticK) ;
   double getAmoebaGlobalHarmonicAngleSextic(void) const ;
   int addAngle(int particle1, int particle2, int particle3, double length, double quadraticK) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply double & OUTPUT { double & length };
   %apply double & OUTPUT { double & quadraticK };
   void getAngleParameters(int index, int &particle1, int &particle2, int &particle3, double &length, double &quadraticK) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear double & length;
   %clear double & quadraticK;
   void setAngleParameters(int index, int particle1, int particle2, int particle3, double length, double quadraticK) ;
};

class AmoebaHarmonicBondForce : public Force {
public:
   AmoebaHarmonicBondForce() ;

   int getNumBonds() const ;
   void setAmoebaGlobalHarmonicBondCubic(double cubicK) ;
   double getAmoebaGlobalHarmonicBondCubic(void) const ;
   void setAmoebaGlobalHarmonicBondQuartic(double quarticK) ;
   double getAmoebaGlobalHarmonicBondQuartic(void) const ;
   int addBond(int particle1, int particle2, double length, double quadraticK) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & length };
   %apply double & OUTPUT { double & quadraticK };
   void getBondParameters(int index, int &particle1, int &particle2, double &length, double &quadraticK) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & length;
   %clear double & quadraticK;
   void setBondParameters(int index, int particle1, int particle2, double length, double quadraticK) ;
};

class AmoebaHarmonicInPlaneAngleForce : public Force {
public:
   AmoebaHarmonicInPlaneAngleForce() ;

   int getNumAngles() const ;
   void setAmoebaGlobalHarmonicInPlaneAngleCubic(double cubicK) ;
   double getAmoebaGlobalHarmonicInPlaneAngleCubic(void) const ;
   void setAmoebaGlobalHarmonicInPlaneAngleQuartic(double quarticK) ;
   double getAmoebaGlobalHarmonicInPlaneAngleQuartic(void) const ;
   void setAmoebaGlobalHarmonicInPlaneAnglePentic(double penticK) ;
   double getAmoebaGlobalHarmonicInPlaneAnglePentic(void) const ;
   void setAmoebaGlobalHarmonicInPlaneAngleSextic(double sexticK) ;
   double getAmoebaGlobalHarmonicInPlaneAngleSextic(void) const ;
   int addAngle(int particle1, int particle2, int particle3, int particle4, double length, double quadraticK) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply double & OUTPUT { double & length };
   %apply double & OUTPUT { double & quadraticK };
   void getAngleParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, double &length, double &quadraticK) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear double & length;
   %clear double & quadraticK;
   void setAngleParameters(int index, int particle1, int particle2, int particle3, int particle4, double length, double quadraticK) ;
};

class AmoebaMultipoleForce : public Force {
public:
   enum AmoebaNonbondedMethod {
      NoCutoff = 0,
      PME = 1
   };
   enum AmoebaPolarizationType {
      Mutual = 0,
      Direct = 1
   };
   enum MultipoleAxisTypes {
      ZThenX = 0,
      Bisector = 1,
      ZBisect = 2,
      ThreeFold = 3,
      ZOnly = 4,
      NoAxisType = 5,
      LastAxisTypeIndex = 6
   };
   enum MutualInducedIterationMethod {
      SOR = 0
   };
   enum CovalentType {
      Covalent12 = 0,
      Covalent13 = 1,
      Covalent14 = 2,
      Covalent15 = 3,
      PolarizationCovalent11 = 4,
      PolarizationCovalent12 = 5,
      PolarizationCovalent13 = 6,
      PolarizationCovalent14 = 7,
      CovalentEnd = 8
   };

   AmoebaMultipoleForce() ;

   int getNumMultipoles() const ;
   AmoebaNonbondedMethod getNonbondedMethod(void) const ;
   void setNonbondedMethod(AmoebaNonbondedMethod method) ;
   AmoebaPolarizationType getPolarizationType(void) const ;
   void setPolarizationType(AmoebaPolarizationType type) ;
   double getCutoffDistance(void) const ;
   void setCutoffDistance(double distance) ;
   double getAEwald() const ;
   void setAEwald(double aewald) ;
   int getPmeBSplineOrder() const ;
   %apply std::vector< int > & OUTPUT { std::vector< int > & gridDimension };
   void getPmeGridDimensions(std::vector< int > &gridDimension) const ;
   %clear std::vector< int > & gridDimension;
   void setPmeGridDimensions(const std::vector< int > &gridDimension) ;
   int addParticle(double charge, const std::vector< double > &molecularDipole, const std::vector< double > &molecularQuadrupole, int axisType, int multipoleAtomZ, int multipoleAtomX, int multipoleAtomY, double thole, double dampingFactor, double polarity) ;
   %apply double & OUTPUT { double & charge };
   %apply std::vector< double > & OUTPUT { std::vector< double > & molecularDipole };
   %apply std::vector< double > & OUTPUT { std::vector< double > & molecularQuadrupole };
   %apply int & OUTPUT { int & axisType };
   %apply int & OUTPUT { int & multipoleAtomZ };
   %apply int & OUTPUT { int & multipoleAtomX };
   %apply int & OUTPUT { int & multipoleAtomY };
   %apply double & OUTPUT { double & thole };
   %apply double & OUTPUT { double & dampingFactor };
   %apply double & OUTPUT { double & polarity };
   void getMultipoleParameters(int index, double &charge, std::vector< double > &molecularDipole, std::vector< double > &molecularQuadrupole, int &axisType, int &multipoleAtomZ, int &multipoleAtomX, int &multipoleAtomY, double &thole, double &dampingFactor, double &polarity) const ;
   %clear double & charge;
   %clear std::vector< double > & molecularDipole;
   %clear std::vector< double > & molecularQuadrupole;
   %clear int & axisType;
   %clear int & multipoleAtomZ;
   %clear int & multipoleAtomX;
   %clear int & multipoleAtomY;
   %clear double & thole;
   %clear double & dampingFactor;
   %clear double & polarity;
   void setMultipoleParameters(int index, double charge, const std::vector< double > &molecularDipole, const std::vector< double > &molecularQuadrupole, int axisType, int multipoleAtomZ, int multipoleAtomX, int multipoleAtomY, double thole, double dampingFactor, double polarity) ;
   void setCovalentMap(int index, CovalentType typeId, const std::vector< int > &covalentAtoms) ;
   %apply std::vector< int > & OUTPUT { std::vector< int > & covalentAtoms };
   void getCovalentMap(int index, CovalentType typeId, std::vector< int > &covalentAtoms) const ;
   %clear std::vector< int > & covalentAtoms;
   %apply std::vector< std::vector< int > > & OUTPUT { std::vector< std::vector< int > > & covalentLists };
   void getCovalentMaps(int index, std::vector< std::vector< int > > &covalentLists) const ;
   %clear std::vector< std::vector< int > > & covalentLists;
   int getMutualInducedMaxIterations(void) const ;
   void setMutualInducedMaxIterations(int inputMutualInducedMaxIterations) ;
   double getMutualInducedTargetEpsilon(void) const ;
   void setMutualInducedTargetEpsilon(double inputMutualInducedTargetEpsilon) ;
   double getEwaldErrorTolerance() const ;
   void setEwaldErrorTolerance(double tol) ;
};

class AmoebaOutOfPlaneBendForce : public Force {
public:
   AmoebaOutOfPlaneBendForce() ;

   int getNumOutOfPlaneBends() const ;
   void setAmoebaGlobalOutOfPlaneBendCubic(double cubicK) ;
   double getAmoebaGlobalOutOfPlaneBendCubic(void) const ;
   void setAmoebaGlobalOutOfPlaneBendQuartic(double quarticK) ;
   double getAmoebaGlobalOutOfPlaneBendQuartic(void) const ;
   void setAmoebaGlobalOutOfPlaneBendPentic(double penticK) ;
   double getAmoebaGlobalOutOfPlaneBendPentic(void) const ;
   void setAmoebaGlobalOutOfPlaneBendSextic(double sexticK) ;
   double getAmoebaGlobalOutOfPlaneBendSextic(void) const ;
   int addOutOfPlaneBend(int particle1, int particle2, int particle3, int particle4, double k) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply double & OUTPUT { double & k };
   void getOutOfPlaneBendParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, double &k) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear double & k;
   void setOutOfPlaneBendParameters(int index, int particle1, int particle2, int particle3, int particle4, double k) ;
};

class AmoebaPiTorsionForce : public Force {
public:
   AmoebaPiTorsionForce() ;

   int getNumPiTorsions() const ;
   int addPiTorsion(int particle1, int particle2, int particle3, int particle4, int particle5, int particle6, double k) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply int & OUTPUT { int & particle5 };
   %apply int & OUTPUT { int & particle6 };
   %apply double & OUTPUT { double & k };
   void getPiTorsionParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, int &particle5, int &particle6, double &k) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear int & particle5;
   %clear int & particle6;
   %clear double & k;
   void setPiTorsionParameters(int index, int particle1, int particle2, int particle3, int particle4, int particle5, int particle6, double k) ;
};

class AmoebaStretchBendForce : public Force {
public:
   AmoebaStretchBendForce() ;

   int getNumStretchBends() const ;
   int addStretchBend(int particle1, int particle2, int particle3, double lengthAB, double lengthCB, double angle, double k) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply double & OUTPUT { double & lengthAB };
   %apply double & OUTPUT { double & lengthCB };
   %apply double & OUTPUT { double & angle };
   %apply double & OUTPUT { double & k };
   void getStretchBendParameters(int index, int &particle1, int &particle2, int &particle3, double &lengthAB, double &lengthCB, double &angle, double &k) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear double & lengthAB;
   %clear double & lengthCB;
   %clear double & angle;
   %clear double & k;
   void setStretchBendParameters(int index, int particle1, int particle2, int particle3, double lengthAB, double lengthCB, double angle, double k) ;
};

class AmoebaTorsionForce : public Force {
public:
   AmoebaTorsionForce() ;

   int getNumTorsions() const ;
   int addTorsion(int particle1, int particle2, int particle3, int particle4, const std::vector< double > &torsion1, const std::vector< double > &torsion2, const std::vector< double > &torsion3) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & torsion1 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & torsion2 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & torsion3 };
   void getTorsionParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, std::vector< double > &torsion1, std::vector< double > &torsion2, std::vector< double > &torsion3) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear std::vector< double > & torsion1;
   %clear std::vector< double > & torsion2;
   %clear std::vector< double > & torsion3;
   void setTorsionParameters(int index, int particle1, int particle2, int particle3, int particle4, const std::vector< double > &torsion1, const std::vector< double > &torsion2, const std::vector< double > &torsion3) ;
};

class AmoebaTorsionTorsionForce : public Force {
public:
   AmoebaTorsionTorsionForce(void) ;

   int getNumTorsionTorsions(void) const ;
   int getNumTorsionTorsionGrids(void) const ;
   int addTorsionTorsion(int particle1, int particle2, int particle3, int particle4, int particle5, int chiralCheckAtomIndex, int gridIndex) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply int & OUTPUT { int & particle5 };
   %apply int & OUTPUT { int & chiralCheckAtomIndex };
   %apply int & OUTPUT { int & gridIndex };
   void getTorsionTorsionParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, int &particle5, int &chiralCheckAtomIndex, int &gridIndex) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear int & particle5;
   %clear int & chiralCheckAtomIndex;
   %clear int & gridIndex;
   void setTorsionTorsionParameters(int index, int particle1, int particle2, int particle3, int particle4, int particle5, int chiralCheckAtomIndex, int gridIndex) ;
   const std::vector< std::vector< std::vector<double> > >& getTorsionTorsionGrid(int index) const ;
   void setTorsionTorsionGrid(int index, const std::vector< std::vector< std::vector< double > > > &grid) ;
};

class AmoebaUreyBradleyForce : public Force {
public:
   AmoebaUreyBradleyForce() ;

   int getNumInteractions() const ;
   void setAmoebaGlobalUreyBradleyCubic(double cubicK) ;
   double getAmoebaGlobalUreyBradleyCubic(void) const ;
   void setAmoebaGlobalUreyBradleyQuartic(double quarticK) ;
   double getAmoebaGlobalUreyBradleyQuartic(void) const ;
   int addUreyBradley(int particle1, int particle2, double length, double quadraticK) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & length };
   %apply double & OUTPUT { double & quadraticK };
   void getUreyBradleyParameters(int index, int &particle1, int &particle2, double &length, double &quadraticK) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & length;
   %clear double & quadraticK;
   void setUreyBradleyParameters(int index, int particle1, int particle2, double length, double quadraticK) ;
};

class AmoebaVdwForce : public Force {
public:
   AmoebaVdwForce() ;

   int getNumParticles() const ;
   void setParticleParameters(int particleIndex, int ivIndex, int classIndex, double sigma, double epsilon, double reductionFactor) ;
   %apply int & OUTPUT { int & ivIndex };
   %apply int & OUTPUT { int & classIndex };
   %apply double & OUTPUT { double & sigma };
   %apply double & OUTPUT { double & epsilon };
   %apply double & OUTPUT { double & reductionFactor };
   void getParticleParameters(int particleIndex, int &ivIndex, int &classIndex, double &sigma, double &epsilon, double &reductionFactor) const ;
   %clear int & ivIndex;
   %clear int & classIndex;
   %clear double & sigma;
   %clear double & epsilon;
   %clear double & reductionFactor;
   int addParticle(int ivIndex, int classIndex, double sigma, double epsilon, double reductionFactor) ;
   void setSigmaCombiningRule(const std::string &sigmaCombiningRule) ;
   const std::string& getSigmaCombiningRule(void) const ;
   void setEpsilonCombiningRule(const std::string &epsilonCombiningRule) ;
   const std::string& getEpsilonCombiningRule(void) const ;
   void setParticleExclusions(int particleIndex, const std::vector< int > &exclusions) ;
   %apply std::vector< int > & OUTPUT { std::vector< int > & exclusions };
   void getParticleExclusions(int particleIndex, std::vector< int > &exclusions) const ;
   %clear std::vector< int > & exclusions;
   void setCutoff(double cutoff) ;
   double getCutoff(void) const ;
   void setUseNeighborList(int neighborListFlag) ;
   int getUseNeighborList(void) const ;
   void setPBC(int pbcFlag) ;
   int getPBC(void) const ;
};

class AmoebaWcaDispersionForce : public Force {
public:
   AmoebaWcaDispersionForce() ;

   int getNumParticles() const ;
   void setParticleParameters(int particleIndex, double radius, double epsilon) ;
   %apply double & OUTPUT { double & radius };
   %apply double & OUTPUT { double & epsilon };
   void getParticleParameters(int particleIndex, double &radius, double &epsilon) const ;
   %clear double & radius;
   %clear double & epsilon;
   int addParticle(double radius, double epsilon) ;
   double getEpso(void) const ;
   double getEpsh(void) const ;
   double getRmino(void) const ;
   double getRminh(void) const ;
   double getAwater(void) const ;
   double getShctd(void) const ;
   double getDispoff(void) const ;
   double getSlevy(void) const ;
   void setEpso(double inputValue) ;
   void setEpsh(double inputValue) ;
   void setRmino(double inputValue) ;
   void setRminh(double inputValue) ;
   void setAwater(double inputValue) ;
   void setShctd(double inputValue) ;
   void setDispoff(double inputValue) ;
   void setSlevy(double inputValue) ;
};

class AndersenThermostat : public Force {
public:
   AndersenThermostat(double defaultTemperature, double defaultCollisionFrequency) ;

   static const std::string& Temperature() ;
   static const std::string& CollisionFrequency() ;
   double getDefaultTemperature() const ;
   double getDefaultCollisionFrequency() const ;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
};

class Integrator {
public:
   virtual ~Integrator() ;

   double getStepSize() const ;
   void setStepSize(double size) ;
   double getConstraintTolerance() const ;
   void setConstraintTolerance(double tol) ;
   virtual void step(int steps)=0 ;
};

class BrownianIntegrator : public Integrator {
public:
   BrownianIntegrator(double temperature, double frictionCoeff, double stepSize) ;

   double getTemperature() const ;
   void setTemperature(double temp) ;
   double getFriction() const ;
   void setFriction(double coeff) ;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
   virtual void step(int steps) ;
};

class CMAPTorsionForce : public Force {
public:
   CMAPTorsionForce() ;

   int getNumMaps() const ;
   int getNumTorsions() const ;
   int addMap(int size, const std::vector< double > &energy) ;
   %apply int & OUTPUT { int & size };
   %apply std::vector< double > & OUTPUT { std::vector< double > & energy };
   void getMapParameters(int index, int &size, std::vector< double > &energy) const ;
   %clear int & size;
   %clear std::vector< double > & energy;
   void setMapParameters(int index, int size, const std::vector< double > &energy) ;
   int addTorsion(int map, int a1, int a2, int a3, int a4, int b1, int b2, int b3, int b4) ;
   %apply int & OUTPUT { int & map };
   %apply int & OUTPUT { int & a1 };
   %apply int & OUTPUT { int & a2 };
   %apply int & OUTPUT { int & a3 };
   %apply int & OUTPUT { int & a4 };
   %apply int & OUTPUT { int & b1 };
   %apply int & OUTPUT { int & b2 };
   %apply int & OUTPUT { int & b3 };
   %apply int & OUTPUT { int & b4 };
   void getTorsionParameters(int index, int &map, int &a1, int &a2, int &a3, int &a4, int &b1, int &b2, int &b3, int &b4) const ;
   %clear int & map;
   %clear int & a1;
   %clear int & a2;
   %clear int & a3;
   %clear int & a4;
   %clear int & b1;
   %clear int & b2;
   %clear int & b3;
   %clear int & b4;
   void setTorsionParameters(int index, int map, int a1, int a2, int a3, int a4, int b1, int b2, int b3, int b4) ;
};

class CMMotionRemover : public Force {
public:
   CMMotionRemover(int frequency=1) ;

   int getFrequency() const ;
   void setFrequency(int freq) ;
};

class Context {
public:
   Context(System &system, Integrator &integrator) ;
   Context(System &system, Integrator &integrator, Platform &platform) ;
   Context(System &system, Integrator &integrator, Platform &platform, const std::map< std::string, std::string > &properties) ;
   ~Context() ;

   const System& getSystem() const ;
   System& getSystem() ;
   const Integrator& getIntegrator() const ;
   Integrator& getIntegrator() ;
   const Platform& getPlatform() const ;
   Platform& getPlatform() ;
   void setTime(double time) ;
%feature("autodoc", "setPositions(self, positions)") setPositions;
   void setPositions(const std::vector< Vec3 > &positions) ;
%feature("autodoc", "setVelocities(self, velocities)") setVelocities;
   void setVelocities(const std::vector< Vec3 > &velocities) ;
   double getParameter(const std::string &name) ;
   void setParameter(const std::string &name, double value) ;
   void setPeriodicBoxVectors(const Vec3 &a, const Vec3 &b, const Vec3 &c) ;
   void applyConstraints(double tol) ;
   void computeVirtualSites() ;
   void reinitialize() ;
};

class CustomAngleForce : public Force {
public:
   CustomAngleForce(const std::string &energy) ;

   int getNumAngles() const ;
   int getNumPerAngleParameters() const ;
   int getNumGlobalParameters() const ;
   const std::string& getEnergyFunction() const ;
   void setEnergyFunction(const std::string &energy) ;
   int addPerAngleParameter(const std::string &name) ;
   const std::string& getPerAngleParameterName(int index) const ;
   void setPerAngleParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addAngle(int particle1, int particle2, int particle3, const std::vector< double > &parameters) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getAngleParameters(int index, int &particle1, int &particle2, int &particle3, std::vector< double > &parameters) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear std::vector< double > & parameters;
   void setAngleParameters(int index, int particle1, int particle2, int particle3, const std::vector< double > &parameters) ;
};

class CustomBondForce : public Force {
public:
   CustomBondForce(const std::string &energy) ;

   int getNumBonds() const ;
   int getNumPerBondParameters() const ;
   int getNumGlobalParameters() const ;
   const std::string& getEnergyFunction() const ;
   void setEnergyFunction(const std::string &energy) ;
   int addPerBondParameter(const std::string &name) ;
   const std::string& getPerBondParameterName(int index) const ;
   void setPerBondParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addBond(int particle1, int particle2, const std::vector< double > &parameters) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getBondParameters(int index, int &particle1, int &particle2, std::vector< double > &parameters) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear std::vector< double > & parameters;
   void setBondParameters(int index, int particle1, int particle2, const std::vector< double > &parameters) ;
};

class CustomExternalForce : public Force {
public:
   CustomExternalForce(const std::string &energy) ;

   int getNumParticles() const ;
   int getNumPerParticleParameters() const ;
   int getNumGlobalParameters() const ;
   const std::string& getEnergyFunction() const ;
   void setEnergyFunction(const std::string &energy) ;
   int addPerParticleParameter(const std::string &name) ;
   const std::string& getPerParticleParameterName(int index) const ;
   void setPerParticleParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addParticle(int particle, const std::vector< double > &parameters) ;
   %apply int & OUTPUT { int & particle };
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getParticleParameters(int index, int &particle, std::vector< double > &parameters) const ;
   %clear int & particle;
   %clear std::vector< double > & parameters;
   void setParticleParameters(int index, int particle, const std::vector< double > &parameters) ;
};

class CustomGBForce : public Force {
public:
   enum NonbondedMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };
   enum ComputationType {
      SingleParticle = 0,
      ParticlePair = 1,
      ParticlePairNoExclusions = 2
   };

   CustomGBForce() ;

   int getNumParticles() const ;
   int getNumExclusions() const ;
   int getNumPerParticleParameters() const ;
   int getNumGlobalParameters() const ;
   int getNumFunctions() const ;
   int getNumComputedValues() const ;
   int getNumEnergyTerms() const ;
   NonbondedMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   int addPerParticleParameter(const std::string &name) ;
   const std::string& getPerParticleParameterName(int index) const ;
   void setPerParticleParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addParticle(const std::vector< double > &parameters) ;
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getParticleParameters(int index, std::vector< double > &parameters) const ;
   %clear std::vector< double > & parameters;
   void setParticleParameters(int index, const std::vector< double > &parameters) ;
   int addComputedValue(const std::string &name, const std::string &expression, ComputationType type) ;
   %apply std::string & OUTPUT { std::string & name };
   %apply std::string & OUTPUT { std::string & expression };
   %apply int & OUTPUT { ComputationType & type };
   void getComputedValueParameters(int index, std::string &name, std::string &expression, ComputationType &type) const ;
   %clear std::string & name;
   %clear std::string & expression;
   %clear ComputationType & type;
   void setComputedValueParameters(int index, const std::string &name, const std::string &expression, ComputationType type) ;
   int addEnergyTerm(const std::string &expression, ComputationType type) ;
   %apply std::string & OUTPUT { std::string & expression };
   %apply int & OUTPUT { ComputationType & type };
   void getEnergyTermParameters(int index, std::string &expression, ComputationType &type) const ;
   %clear std::string & expression;
   %clear ComputationType & type;
   void setEnergyTermParameters(int index, const std::string &expression, ComputationType type) ;
   int addExclusion(int particle1, int particle2) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   void getExclusionParticles(int index, int &particle1, int &particle2) const ;
   %clear int & particle1;
   %clear int & particle2;
   void setExclusionParticles(int index, int particle1, int particle2) ;
   int addFunction(const std::string &name, const std::vector< double > &values, double min, double max) ;
   %apply std::string & OUTPUT { std::string & name };
   %apply std::vector< double > & OUTPUT { std::vector< double > & values };
   %apply double & OUTPUT { double & min };
   %apply double & OUTPUT { double & max };
   void getFunctionParameters(int index, std::string &name, std::vector< double > &values, double &min, double &max) const ;
   %clear std::string & name;
   %clear std::vector< double > & values;
   %clear double & min;
   %clear double & max;
   void setFunctionParameters(int index, const std::string &name, const std::vector< double > &values, double min, double max) ;
};

class CustomHbondForce : public Force {
public:
   enum NonbondedMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };

   CustomHbondForce(const std::string &energy) ;

   int getNumDonors() const ;
   int getNumAcceptors() const ;
   int getNumExclusions() const ;
   int getNumPerDonorParameters() const ;
   int getNumPerAcceptorParameters() const ;
   int getNumGlobalParameters() const ;
   int getNumFunctions() const ;
   const std::string& getEnergyFunction() const ;
   void setEnergyFunction(const std::string &energy) ;
   NonbondedMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   int addPerDonorParameter(const std::string &name) ;
   const std::string& getPerDonorParameterName(int index) const ;
   void setPerDonorParameterName(int index, const std::string &name) ;
   int addPerAcceptorParameter(const std::string &name) ;
   const std::string& getPerAcceptorParameterName(int index) const ;
   void setPerAcceptorParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addDonor(int d1, int d2, int d3, const std::vector< double > &parameters) ;
   %apply int & OUTPUT { int & d1 };
   %apply int & OUTPUT { int & d2 };
   %apply int & OUTPUT { int & d3 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getDonorParameters(int index, int &d1, int &d2, int &d3, std::vector< double > &parameters) const ;
   %clear int & d1;
   %clear int & d2;
   %clear int & d3;
   %clear std::vector< double > & parameters;
   void setDonorParameters(int index, int d1, int d2, int d3, const std::vector< double > &parameters) ;
   int addAcceptor(int a1, int a2, int a3, const std::vector< double > &parameters) ;
   %apply int & OUTPUT { int & a1 };
   %apply int & OUTPUT { int & a2 };
   %apply int & OUTPUT { int & a3 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getAcceptorParameters(int index, int &a1, int &a2, int &a3, std::vector< double > &parameters) const ;
   %clear int & a1;
   %clear int & a2;
   %clear int & a3;
   %clear std::vector< double > & parameters;
   void setAcceptorParameters(int index, int a1, int a2, int a3, const std::vector< double > &parameters) ;
   int addExclusion(int donor, int acceptor) ;
   %apply int & OUTPUT { int & donor };
   %apply int & OUTPUT { int & acceptor };
   void getExclusionParticles(int index, int &donor, int &acceptor) const ;
   %clear int & donor;
   %clear int & acceptor;
   void setExclusionParticles(int index, int donor, int acceptor) ;
   int addFunction(const std::string &name, const std::vector< double > &values, double min, double max) ;
   %apply std::string & OUTPUT { std::string & name };
   %apply std::vector< double > & OUTPUT { std::vector< double > & values };
   %apply double & OUTPUT { double & min };
   %apply double & OUTPUT { double & max };
   void getFunctionParameters(int index, std::string &name, std::vector< double > &values, double &min, double &max) const ;
   %clear std::string & name;
   %clear std::vector< double > & values;
   %clear double & min;
   %clear double & max;
   void setFunctionParameters(int index, const std::string &name, const std::vector< double > &values, double min, double max) ;
};

class CustomIntegrator : public Integrator {
public:
   enum ComputationType {
      ComputeGlobal = 0,
      ComputePerDof = 1,
      ComputeSum = 2,
      ConstrainPositions = 3,
      ConstrainVelocities = 4,
      UpdateContextState = 5
   };

   CustomIntegrator(double stepSize) ;

   int getNumGlobalVariables() const ;
   int getNumPerDofVariables() const ;
   int getNumComputations() const ;
   int addGlobalVariable(const std::string &name, double initialValue) ;
   const std::string& getGlobalVariableName(int index) const ;
   int addPerDofVariable(const std::string &name, double initialValue) ;
   const std::string& getPerDofVariableName(int index) const ;
   double getGlobalVariable(int index) const ;
   void setGlobalVariable(int index, double value) ;
   void setGlobalVariableByName(const std::string &name, double value) ;
   %apply std::vector< Vec3 > & OUTPUT { std::vector< Vec3 > & values };
   void getPerDofVariable(int index, std::vector< Vec3 > &values) const ;
   %clear std::vector< Vec3 > & values;
   void setPerDofVariable(int index, const std::vector< Vec3 > &values) ;
   void setPerDofVariableByName(const std::string &name, const std::vector< Vec3 > &values) ;
   int addComputeGlobal(const std::string &variable, const std::string &expression) ;
   int addComputePerDof(const std::string &variable, const std::string &expression) ;
   int addComputeSum(const std::string &variable, const std::string &expression) ;
   int addConstrainPositions() ;
   int addConstrainVelocities() ;
   int addUpdateContextState() ;
   %apply int & OUTPUT { ComputationType & type };
   %apply std::string & OUTPUT { std::string & variable };
   %apply std::string & OUTPUT { std::string & expression };
   void getComputationStep(int index, ComputationType &type, std::string &variable, std::string &expression) const ;
   %clear ComputationType & type;
   %clear std::string & variable;
   %clear std::string & expression;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
   virtual void step(int steps) ;
};

class CustomNonbondedForce : public Force {
public:
   enum NonbondedMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };

   CustomNonbondedForce(const std::string &energy) ;

   int getNumParticles() const ;
   int getNumExclusions() const ;
   int getNumPerParticleParameters() const ;
   int getNumGlobalParameters() const ;
   int getNumFunctions() const ;
   const std::string& getEnergyFunction() const ;
   void setEnergyFunction(const std::string &energy) ;
   NonbondedMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   int addPerParticleParameter(const std::string &name) ;
   const std::string& getPerParticleParameterName(int index) const ;
   void setPerParticleParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addParticle(const std::vector< double > &parameters) ;
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getParticleParameters(int index, std::vector< double > &parameters) const ;
   %clear std::vector< double > & parameters;
   void setParticleParameters(int index, const std::vector< double > &parameters) ;
   int addExclusion(int particle1, int particle2) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   void getExclusionParticles(int index, int &particle1, int &particle2) const ;
   %clear int & particle1;
   %clear int & particle2;
   void setExclusionParticles(int index, int particle1, int particle2) ;
   int addFunction(const std::string &name, const std::vector< double > &values, double min, double max) ;
   %apply std::string & OUTPUT { std::string & name };
   %apply std::vector< double > & OUTPUT { std::vector< double > & values };
   %apply double & OUTPUT { double & min };
   %apply double & OUTPUT { double & max };
   void getFunctionParameters(int index, std::string &name, std::vector< double > &values, double &min, double &max) const ;
   %clear std::string & name;
   %clear std::vector< double > & values;
   %clear double & min;
   %clear double & max;
   void setFunctionParameters(int index, const std::string &name, const std::vector< double > &values, double min, double max) ;
};

class CustomTorsionForce : public Force {
public:
   CustomTorsionForce(const std::string &energy) ;

   int getNumTorsions() const ;
   int getNumPerTorsionParameters() const ;
   int getNumGlobalParameters() const ;
   const std::string& getEnergyFunction() const ;
   void setEnergyFunction(const std::string &energy) ;
   int addPerTorsionParameter(const std::string &name) ;
   const std::string& getPerTorsionParameterName(int index) const ;
   void setPerTorsionParameterName(int index, const std::string &name) ;
   int addGlobalParameter(const std::string &name, double defaultValue) ;
   const std::string& getGlobalParameterName(int index) const ;
   void setGlobalParameterName(int index, const std::string &name) ;
   double getGlobalParameterDefaultValue(int index) const ;
   void setGlobalParameterDefaultValue(int index, double defaultValue) ;
   int addTorsion(int particle1, int particle2, int particle3, int particle4, const std::vector< double > &parameters) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply std::vector< double > & OUTPUT { std::vector< double > & parameters };
   void getTorsionParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, std::vector< double > &parameters) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear std::vector< double > & parameters;
   void setTorsionParameters(int index, int particle1, int particle2, int particle3, int particle4, const std::vector< double > &parameters) ;
};

class GBSAOBCForce : public Force {
public:
   enum NonbondedMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };

   GBSAOBCForce() ;

   int getNumParticles() const ;
   int addParticle(double charge, double radius, double scalingFactor) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & radius };
   %apply double & OUTPUT { double & scalingFactor };
   void getParticleParameters(int index, double &charge, double &radius, double &scalingFactor) const ;
   %clear double & charge;
   %clear double & radius;
   %clear double & scalingFactor;
   void setParticleParameters(int index, double charge, double radius, double scalingFactor) ;
   double getSolventDielectric() const ;
   void setSolventDielectric(double dielectric) ;
   double getSoluteDielectric() const ;
   void setSoluteDielectric(double dielectric) ;
   NonbondedMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
};

class GBSAOBCSoftcoreForce : public Force {
public:
   enum NonbondedSoftcoreMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };

   GBSAOBCSoftcoreForce() ;

   int getNumParticles() const ;
   int addParticle(double charge, double radius, double scalingFactor, double nonPolarScalingFactor=1.0) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & radius };
   %apply double & OUTPUT { double & scalingFactor };
   %apply double & OUTPUT { double & nonPolarScalingFactor };
   void getParticleParameters(int index, double &charge, double &radius, double &scalingFactor, double &nonPolarScalingFactor) const ;
   %clear double & charge;
   %clear double & radius;
   %clear double & scalingFactor;
   %clear double & nonPolarScalingFactor;
   void setParticleParameters(int index, double charge, double radius, double scalingFactor, double nonPolarScalingFactor=1.0) ;
   double getSolventDielectric() const ;
   void setSolventDielectric(double dielectric) ;
   double getSoluteDielectric() const ;
   void setSoluteDielectric(double dielectric) ;
   double getNonPolarPrefactor() const ;
   void setNonPolarPrefactor(double inputNonPolarPrefactor) ;
   NonbondedSoftcoreMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedSoftcoreMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
};

class GBVIForce : public Force {
public:
   enum NonbondedMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };
   enum BornRadiusScalingMethod {
      NoScaling = 0,
      QuinticSpline = 1
   };

   GBVIForce() ;

   int getNumParticles() const ;
   int addParticle(double charge, double radius, double gamma) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & radius };
   %apply double & OUTPUT { double & gamma };
   void getParticleParameters(int index, double &charge, double &radius, double &gamma) const ;
   %clear double & charge;
   %clear double & radius;
   %clear double & gamma;
   void setParticleParameters(int index, double charge, double radius, double gamma) ;
   int addBond(int particle1, int particle2, double distance) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & distance };
   void getBondParameters(int index, int &particle1, int &particle2, double &distance) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & distance;
   void setBondParameters(int index, int particle1, int particle2, double bondLength) ;
   int getNumBonds(void) const ;
   double getSolventDielectric() const ;
   void setSolventDielectric(double dielectric) ;
   double getSoluteDielectric() const ;
   void setSoluteDielectric(double dielectric) ;
   NonbondedMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   BornRadiusScalingMethod getBornRadiusScalingMethod(void) const ;
   void setBornRadiusScalingMethod(BornRadiusScalingMethod method) ;
   double getQuinticLowerLimitFactor(void) const ;
   void setQuinticLowerLimitFactor(double quinticLowerLimitFactor) ;
   double getQuinticUpperBornRadiusLimit(void) const ;
   void setQuinticUpperBornRadiusLimit(double quinticUpperBornRadiusLimit) ;
};

class GBVISoftcoreForce : public Force {
public:
   enum NonbondedSoftcoreMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };
   enum BornRadiusScalingSoftcoreMethod {
      NoScaling = 0,
      QuinticSpline = 2
   };

   GBVISoftcoreForce() ;

   int getNumParticles() const ;
   void addParticle(double charge, double radius, double gamma, double bornRadiusScaleFactor=1.0) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & radius };
   %apply double & OUTPUT { double & gamma };
   %apply double & OUTPUT { double & bornRadiusScaleFactor };
   void getParticleParameters(int index, double &charge, double &radius, double &gamma, double &bornRadiusScaleFactor) const ;
   %clear double & charge;
   %clear double & radius;
   %clear double & gamma;
   %clear double & bornRadiusScaleFactor;
   void setParticleParameters(int index, double charge, double radius, double gamma, double bornRadiusScaleFactor=1.0) ;
   int addBond(int particle1, int particle2, double distance) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & distance };
   void getBondParameters(int index, int &particle1, int &particle2, double &distance) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & distance;
   void setBondParameters(int index, int particle1, int particle2, double bondLength) ;
   int getNumBonds(void) const ;
   double getSolventDielectric() const ;
   void setSolventDielectric(double dielectric) ;
   double getSoluteDielectric() const ;
   void setSoluteDielectric(double dielectric) ;
   NonbondedSoftcoreMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedSoftcoreMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   BornRadiusScalingSoftcoreMethod getBornRadiusScalingMethod() const ;
   void setBornRadiusScalingMethod(BornRadiusScalingSoftcoreMethod method) ;
   double getQuinticLowerLimitFactor(void) const ;
   void setQuinticLowerLimitFactor(double quinticLowerLimitFactor) ;
   double getQuinticUpperBornRadiusLimit(void) const ;
   void setQuinticUpperBornRadiusLimit(double quinticUpperBornRadiusLimit) ;
};

class HarmonicAngleForce : public Force {
public:
   HarmonicAngleForce() ;

   int getNumAngles() const ;
   int addAngle(int particle1, int particle2, int particle3, double angle, double k) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply double & OUTPUT { double & angle };
   %apply double & OUTPUT { double & k };
   void getAngleParameters(int index, int &particle1, int &particle2, int &particle3, double &angle, double &k) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear double & angle;
   %clear double & k;
   void setAngleParameters(int index, int particle1, int particle2, int particle3, double angle, double k) ;
};

class HarmonicBondForce : public Force {
public:
   HarmonicBondForce() ;

   int getNumBonds() const ;
   int addBond(int particle1, int particle2, double length, double k) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & length };
   %apply double & OUTPUT { double & k };
   void getBondParameters(int index, int &particle1, int &particle2, double &length, double &k) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & length;
   %clear double & k;
   void setBondParameters(int index, int particle1, int particle2, double length, double k) ;
};

class LangevinIntegrator : public Integrator {
public:
   LangevinIntegrator(double temperature, double frictionCoeff, double stepSize) ;

   double getTemperature() const ;
   void setTemperature(double temp) ;
   double getFriction() const ;
   void setFriction(double coeff) ;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
   virtual void step(int steps) ;
};

class LocalEnergyMinimizer {
public:

   static void minimize(Context &context, double tolerance=1, int maxIterations=0) ;
};

class MonteCarloBarostat : public Force {
public:
   MonteCarloBarostat(double defaultPressure, double temperature, int frequency=25) ;

   static const std::string& Pressure() ;
   double getDefaultPressure() const ;
   int getFrequency() const ;
   void setFrequency(int freq) ;
   double getTemperature() const ;
   void setTemperature(double temp) ;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
};

class NonbondedForce : public Force {
public:
   enum NonbondedMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2,
      Ewald = 3,
      PME = 4
   };

   NonbondedForce() ;

   int getNumParticles() const ;
   int getNumExceptions() const ;
   NonbondedMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   double getReactionFieldDielectric() const ;
   void setReactionFieldDielectric(double dielectric) ;
   double getEwaldErrorTolerance() const ;
   void setEwaldErrorTolerance(double tol) ;
   int addParticle(double charge, double sigma, double epsilon) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & sigma };
   %apply double & OUTPUT { double & epsilon };
   void getParticleParameters(int index, double &charge, double &sigma, double &epsilon) const ;
   %clear double & charge;
   %clear double & sigma;
   %clear double & epsilon;
   void setParticleParameters(int index, double charge, double sigma, double epsilon) ;
   int addException(int particle1, int particle2, double chargeProd, double sigma, double epsilon, bool replace=false) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & chargeProd };
   %apply double & OUTPUT { double & sigma };
   %apply double & OUTPUT { double & epsilon };
   void getExceptionParameters(int index, int &particle1, int &particle2, double &chargeProd, double &sigma, double &epsilon) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & chargeProd;
   %clear double & sigma;
   %clear double & epsilon;
   void setExceptionParameters(int index, int particle1, int particle2, double chargeProd, double sigma, double epsilon) ;
   void createExceptionsFromBonds(const std::vector< std::pair< int, int > > &bonds, double coulomb14Scale, double lj14Scale) ;
   bool getUseDispersionCorrection() const ;
   void setUseDispersionCorrection(bool useCorrection) ;
   int getReciprocalSpaceForceGroup() const ;
   void setReciprocalSpaceForceGroup(int group) ;
};

class NonbondedSoftcoreForce : public Force {
public:
   enum NonbondedSoftcoreMethod {
      NoCutoff = 0,
      CutoffNonPeriodic = 1,
      CutoffPeriodic = 2
   };

   NonbondedSoftcoreForce() ;

   int getNumParticles() const ;
   int getNumExceptions() const ;
   NonbondedSoftcoreMethod getNonbondedMethod() const ;
   void setNonbondedMethod(NonbondedSoftcoreMethod method) ;
   double getCutoffDistance() const ;
   void setCutoffDistance(double distance) ;
   double getReactionFieldDielectric() const ;
   void setReactionFieldDielectric(double dielectric) ;
   int addParticle(double charge, double sigma, double epsilon, double softcoreLJLambda=1.0) ;
   %apply double & OUTPUT { double & charge };
   %apply double & OUTPUT { double & sigma };
   %apply double & OUTPUT { double & epsilon };
   %apply double & OUTPUT { double & softcoreLJLambda };
   void getParticleParameters(int index, double &charge, double &sigma, double &epsilon, double &softcoreLJLambda) const ;
   %clear double & charge;
   %clear double & sigma;
   %clear double & epsilon;
   %clear double & softcoreLJLambda;
   void setParticleParameters(int index, double charge, double sigma, double epsilon, double softcoreLJLambda=1.0) ;
   int addException(int particle1, int particle2, double chargeProd, double sigma, double epsilon, bool replace=false, double softcoreLJLambda=1.0) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & chargeProd };
   %apply double & OUTPUT { double & sigma };
   %apply double & OUTPUT { double & epsilon };
   %apply double & OUTPUT { double & softcoreLJLambda };
   void getExceptionParameters(int index, int &particle1, int &particle2, double &chargeProd, double &sigma, double &epsilon, double &softcoreLJLambda) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & chargeProd;
   %clear double & sigma;
   %clear double & epsilon;
   %clear double & softcoreLJLambda;
   void setExceptionParameters(int index, int particle1, int particle2, double chargeProd, double sigma, double epsilon, double softcoreLJLambda=1.0) ;
   void createExceptionsFromBonds(const std::vector< std::pair< int, int > > &bonds, double coulomb14Scale, double lj14Scale) ;
};

class OpenMMException : public std::exception {
public:
   OpenMMException(const std::string &message) ;
   ~OpenMMException() throw ();

   const char* what() const throw ();
};

class VirtualSite {
public:
   virtual ~VirtualSite() ;

   int getNumParticles() const ;
   int getParticle(int particle) const ;
};

class OutOfPlaneSite : public VirtualSite {
public:
   OutOfPlaneSite(int particle1, int particle2, int particle3, double weight12, double weight13, double weightCross) ;

   double getWeight12() const ;
   double getWeight13() const ;
   double getWeightCross() const ;
};

class PeriodicTorsionForce : public Force {
public:
   PeriodicTorsionForce() ;

   int getNumTorsions() const ;
   int addTorsion(int particle1, int particle2, int particle3, int particle4, int periodicity, double phase, double k) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply int & OUTPUT { int & periodicity };
   %apply double & OUTPUT { double & phase };
   %apply double & OUTPUT { double & k };
   void getTorsionParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, int &periodicity, double &phase, double &k) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear int & periodicity;
   %clear double & phase;
   %clear double & k;
   void setTorsionParameters(int index, int particle1, int particle2, int particle3, int particle4, int periodicity, double phase, double k) ;
};

class Platform {
public:
   virtual ~Platform() ;

   static void registerPlatform(Platform *platform) ;
   static int getNumPlatforms() ;
   static Platform& getPlatform(int index) ;
   static Platform& getPlatformByName(const std::string &name) ;
   static Platform& findPlatform(const std::vector< std::string > &kernelNames) ;
   static void loadPluginLibrary(const std::string &file) ;
   static std::vector<std::string> loadPluginsFromDirectory(const std::string &directory) ;
   static const std::string& getDefaultPluginsDirectory() ;
   static const std::string& getOpenMMVersion() ;
   virtual const std::string& getName() const =0 ;
   virtual double getSpeed() const =0 ;
   virtual bool supportsDoublePrecision() const =0 ;
   const std::vector<std::string>& getPropertyNames() ;
   virtual const std::string& getPropertyValue(const Context &context, const std::string &property) const ;
   virtual void setPropertyValue(Context &context, const std::string &property, const std::string &value) const ;
   const std::string& getPropertyDefaultValue(const std::string &property) const ;
   void setPropertyDefaultValue(const std::string &property, const std::string &value) ;
   bool supportsKernels(const std::vector< std::string > &kernelNames) const ;
};

class RBTorsionForce : public Force {
public:
   RBTorsionForce() ;

   int getNumTorsions() const ;
   int addTorsion(int particle1, int particle2, int particle3, int particle4, double c0, double c1, double c2, double c3, double c4, double c5) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply int & OUTPUT { int & particle3 };
   %apply int & OUTPUT { int & particle4 };
   %apply double & OUTPUT { double & c0 };
   %apply double & OUTPUT { double & c1 };
   %apply double & OUTPUT { double & c2 };
   %apply double & OUTPUT { double & c3 };
   %apply double & OUTPUT { double & c4 };
   %apply double & OUTPUT { double & c5 };
   void getTorsionParameters(int index, int &particle1, int &particle2, int &particle3, int &particle4, double &c0, double &c1, double &c2, double &c3, double &c4, double &c5) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear int & particle3;
   %clear int & particle4;
   %clear double & c0;
   %clear double & c1;
   %clear double & c2;
   %clear double & c3;
   %clear double & c4;
   %clear double & c5;
   void setTorsionParameters(int index, int particle1, int particle2, int particle3, int particle4, double c0, double c1, double c2, double c3, double c4, double c5) ;
};

class RPMDIntegrator : public Integrator {
public:
   RPMDIntegrator(int numCopies, double temperature, double frictionCoeff, double stepSize) ;

   int getNumCopies() const ;
   double getTemperature() const ;
   void setTemperature(double temp) ;
   double getFriction() const ;
   void setFriction(double coeff) ;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
   void setPositions(int copy, const std::vector< Vec3 > &positions) ;
   void setVelocities(int copy, const std::vector< Vec3 > &velocities) ;
   virtual void step(int steps) ;
};

class SerializationNode {
public:

   const std::string& getName() const ;
   void setName(const std::string &name) ;
   const std::vector<SerializationNode>& getChildren() const ;
   std::vector<SerializationNode>& getChildren() ;
   const SerializationNode& getChildNode(const std::string &name) const ;
   SerializationNode& getChildNode(const std::string &name) ;
   const std::map<std::string, std::string>& getProperties() const ;
   bool hasProperty(const std::string &name) const ;
   const std::string& getStringProperty(const std::string &name) const ;
   const std::string& getStringProperty(const std::string &name, const std::string &defaultValue) const ;
   SerializationNode& setStringProperty(const std::string &name, const std::string &value) ;
   int getIntProperty(const std::string &name) const ;
   int getIntProperty(const std::string &name, int defaultValue) const ;
   SerializationNode& setIntProperty(const std::string &name, int value) ;
   double getDoubleProperty(const std::string &name) const ;
   double getDoubleProperty(const std::string &name, double defaultValue) const ;
   SerializationNode& setDoubleProperty(const std::string &name, double value) ;
   SerializationNode& createChildNode(const std::string &name) ;
   template<class T > SerializationNode& createChildNode(const std::string &name, const T *object) ;
   template<class T > T* decodeObject() const ;
};

class SerializationProxy {
public:
   SerializationProxy(const std::string &typeName) ;

   static void registerProxy(const std::type_info &type, const SerializationProxy *proxy) ;
   static const SerializationProxy& getProxy(const std::string &typeName) ;
   static const SerializationProxy& getProxy(const std::type_info &type) ;
   const std::string& getTypeName() const ;
   %apply SerializationNode & OUTPUT { SerializationNode & node };
   virtual void serialize(const void *object, SerializationNode &node) const =0 ;
   %clear SerializationNode & node;
   virtual void* deserialize(const SerializationNode &node) const =0 ;
};

class System {
public:
   System() ;
   ~System() ;

   int getNumParticles() const ;
   int addParticle(double mass) ;
   double getParticleMass(int index) const ;
   void setParticleMass(int index, double mass) ;
   void setVirtualSite(int index, VirtualSite *virtualSite) ;
   bool isVirtualSite(int index) const ;
   const VirtualSite& getVirtualSite(int index) const ;
   int getNumConstraints() const ;
   int addConstraint(int particle1, int particle2, double distance) ;
   %apply int & OUTPUT { int & particle1 };
   %apply int & OUTPUT { int & particle2 };
   %apply double & OUTPUT { double & distance };
   void getConstraintParameters(int index, int &particle1, int &particle2, double &distance) const ;
   %clear int & particle1;
   %clear int & particle2;
   %clear double & distance;
   void setConstraintParameters(int index, int particle1, int particle2, double distance) ;
   int addForce(Force *force) ;
   int getNumForces() const ;
   const Force& getForce(int index) const ;
   Force& getForce(int index) ;
   void getDefaultPeriodicBoxVectors(Vec3 &a, Vec3 &b, Vec3 &c) const ;
   void setDefaultPeriodicBoxVectors(const Vec3 &a, const Vec3 &b, const Vec3 &c) ;
};

class ThreeParticleAverageSite : public VirtualSite {
public:
   ThreeParticleAverageSite(int particle1, int particle2, int particle3, double weight1, double weight2, double weight3) ;

   double getWeight(int particle) const ;
};

class TwoParticleAverageSite : public VirtualSite {
public:
   TwoParticleAverageSite(int particle1, int particle2, double weight1, double weight2) ;

   double getWeight(int particle) const ;
};

class VariableLangevinIntegrator : public Integrator {
public:
   VariableLangevinIntegrator(double temperature, double frictionCoeff, double errorTol) ;

   double getTemperature() const ;
   void setTemperature(double temp) ;
   double getFriction() const ;
   void setFriction(double coeff) ;
   double getErrorTolerance() const ;
   void setErrorTolerance(double tol) ;
   int getRandomNumberSeed() const ;
   void setRandomNumberSeed(int seed) ;
   virtual void step(int steps) ;
   void stepTo(double time) ;
};

class VariableVerletIntegrator : public Integrator {
public:
   VariableVerletIntegrator(double errorTol) ;

   double getErrorTolerance() const ;
   void setErrorTolerance(double tol) ;
   virtual void step(int steps) ;
   void stepTo(double time) ;
};

class VerletIntegrator : public Integrator {
public:
   VerletIntegrator(double stepSize) ;

   virtual void step(int steps) ;
};

class XmlSerializer {
public:

   %apply std::ostream & OUTPUT { std::ostream & stream };
   template<class T > static void serialize(const T *object, const std::string &rootName, std::ostream &stream) ;
   %clear std::ostream & stream;
   %apply std::istream & OUTPUT { std::istream & stream };
   template<class T > static T* deserialize(std::istream &stream) ;
   %clear std::istream & stream;
   %extend {
       static std::string serializeSystem( const OpenMM::System *object ){
           std::stringstream ss;
           XmlSerializer::serialize<OpenMM::System>( object, "System", ss );
           return ss.str();
       }

       static OpenMM::System* deserializeSystem( const char* inputString ){
           std::stringstream ss;
           ss << inputString;
           return XmlSerializer::deserialize<OpenMM::System>( ss );
       }
    };

};



} // namespace OpenMM

